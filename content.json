[{"title":"1.1 基础知识、JS、JS引入\\输出方式、变量","date":"2017-05-15T14:59:14.000Z","path":"2017/05/15/1-1 基础知识/","text":"JS的组成 ECMAScript(5,6) 简称ES6：js的核心部分；规定js中命名规范、变量、数据类型、基本语法、操作语句… DOM document object model 文档对象模型；js中提供了操作html元素的属性和方法 BOM browser object model 浏览器对象模型；js中提供了操作浏览器的属性和方法 引申：js 一般写在body最后面，因为js是用来操作html元素的，先保证html加载完之后，再加载js JS引入方式 行内式：将js代码写在div标签里面，和css行内样式一样，很少使用 1234&lt;div style=\"width: 200px;height: 200px;background: red;border-radius: 50%\" onclick=\"alert(123)\"&gt;&lt;/div&gt;&lt;!-- onclick=\"alert(123)\" ---js的代码 //点击当前div时执行的操作=\"弹出123\"//如果行内式js代码写在div上，就是点击div时执行的操作 内嵌式：写在script标签块中 123&lt;script type=\"text/javascript\"&gt; alert(\"第十六期开课了\")&lt;/script&gt; 引入式：引入外部js文件，scr：js文件的路径 12345&lt;script src=\"js/jsluj.js\"&gt; //这里是引入外链式的路径 alert(\"heheda\") //在外链式里的js代码不执行，但不会报错，&lt;/script&gt;// 然后再js的新文件中写上// alert(\"hehe\") 导入式：在js文件中引入另一个js文件的路径 1document.write('&lt;script src=\"2.js\"&gt;&lt;/script&gt;') JS输出方式 alert(要输出的内容)：弹窗；在页面弹出一个窗口 console.log：在浏览器控制台输出显示内容，除此之外还有：显示代码的报错 console.log(‘content’)：一般用于调试js代码；用户看不到 console.warn(‘’)：警告；控制台显示警告内容 console.error(‘’)：报错 console.info(‘’)：信息 console.dir(‘’)：输出对象详细信息 console.table(‘’)：是以表格的形式输出，嵌套2层2层以上 console.clear(‘’)：清除控制台中console的内容 document.write(‘’)：在页面中显示；显示在script标签后面，可以识别html标签；面向对象整个document，document.write(&#39;&lt;h1&gt;输出方式&lt;/h1&gt;&#39;); innerHTML/innerText：向指定的元素添加内容div.innerHTML=&#39;&lt;h1&gt;珠峰培训&lt;/h1&gt;&#39; innerHTML：可以识别html标签div1.innerHTML = &#39;&lt;h1&gt;珠峰培训&lt;/h1&gt;&#39; innerText：不可以识别html标签 命名规范（对象名） 在js中严格区分大小写 oBox 遵循驼峰命名法：第一个单词首字母小写，从第二个单词首字母大写，studentManageInfo 由：数字、字母、下划线_、$ 组成，不能以数字作为开头， 遵循匈牙利命名法： 不能使用关键字和保留字 关键字：在js中有特殊意义的单词，typeof、if 、else、var等 保留字：未来可能成为关键字的。 JS中的变量 变量概念：可以变化的元素、内容，抽象来说是一个容器，可以再容器中放任何的东西。 变量作用：用来存储值和代表值。输出的时候不可以输出变量名，只能输出变量所代表和存储的值。 用var来声明一个变量：var可以声明任何类型的变量 var 变量名=变量值;变量名可以随便起，但要遵循js的命名规范 = 赋值：将=右边的值赋值给等号左边的变量 变量值：具体的值 变量可以声明多次，如果出现重复，后面重复的会将前面的变量替换掉。123var a = 123;var str = \"cbxm\";console.log(a);//变量所代表的值 “box”：有引号为字符串，是具体的值box：没有引号是变量，可以是任意数字 JS中的数据类型1. 基本数据类型 number：数字数据类型var num=123 string：字符串数据类型var str=&#39;cbxm&#39;用引号引起来的都叫做字符串 boolean：布尔数据类型 ;只有两个值true和false var boo = true; null：null数据类型；意思是空，现在没有以后可能会有 var n = null;//空 undefined：未定义数据类型；意思是没有定义；现在没有以后也不会有var u = undefined; 2. 引用数据类型 对象数据类型 { }：大括号里的对象数据类型var obj = {name: &#39;cbxm&#39;,a:2,b:3}//{} 对象 对象数据类型 object [ ]：中括号里的数组数据类型var ary = [1, 2, 3]//[]数组 /^90$/：斜杠里的正则数据类型 var reg = /\\d{10}/;// /一堆字符/ 正则 函数数据类型： function ( ) { } ；大括号小括号是固定格式","tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"},{"name":"js入门","slug":"js入门","permalink":"http://yoursite.com/tags/js入门/"}]},{"title":"REM+流式布局","date":"2017-02-20T07:39:10.000Z","path":"2017/02/20/Rem布局/","text":"知识点 inline-block 默认左右两边有空白的间隙：直接在最外面那一层给他加一个font-size=0 解决 浮动清除，overflow，clearfix white-space: nowrap 强制不折行 ::-webkit-scrollbar{display: none;} 利用伪类让滚动条隐藏 box-sizing:border-box;/*会把边框值padding值都算到总的宽度内*/-webkit-box-sizing:border-box;响应式布局： 流式布局：宽度不要写死，用百分比；pc和手机公用一套结构，用媒体查询来做；如果要兼容到移动端，就要考虑到百分比。会随着宽度的放大和缩小，改变元素的位置，如果网页缩小到移动端的宽度，用媒体查询 REM布局：（root element 根元素）（font size of root element） 根元素的字体大小 html为根元素 font-size值 1rem=100px（默认设置1rem=100px，是因为100px比较好计算。） 移动端默认的 1rem = 16px 我们换算成 1rem =100px 是因为100px 比较好计算。为最小的值，1px = 1/16 1.产品形态： 1)pc和移动端(手机、ipad)公用一套html结构 例如:猎豹 华为2)pc和移动端分离开 www.ifeng.com i.ifeng.com i/m 移动端的网址 2.响应式布局的思想： 1)流式布局 + px + 媒体查询 宽度不要写死 用百分比2)流式布局+ rem(js动态计算html跟元素的字体大小) 一般我们才用这种方式来使用3)flexbox 弹性布局 (下周) 3.设计稿的尺寸 调整rem PC:宽屏和窄屏移动端: iphone5 6401136 单屏 &gt;1136 多屏 iphone6 7501334 单屏 &gt;1134 多屏 iphone6 plus 12422208 单屏 &gt;2208 多屏psd的设计稿3202 640 iphone53752 750 iphone64143 1242 iphone6 plus 根据提供的设计稿，可以推算出在不同设备的 情况下，不同的rem尺寸640 100px font-size320 x iphone5375 y iphone6488 z推算出这样一个计算公式：html fontSize 根目录的字体大小 = (设备的宽度/设计稿)100x=(320100)/640 求未知数 123456~function () &#123; var desW = 640,//设计稿是640这里的就是640，如果你拿到的设计稿是750 设置为750，记住var后面加“，”因为的连var功能 winW = document.documentElement.clientWidth, ratio = winW / desW; document.documentElement.style.fontSize = ratio * 100 + &apos;px&apos;;//一般将rem设置为100px的像素，所以这里要乘以100px &#125;() 4.计算rem(font size of root element) 1rem=16px 100100 1rem1remhtml{ font-size:100px; 方便计算 10px 12px 1rem=100px;}640设计稿 100px320设备的尺寸 x (html fontSize) 切图的几种形式 通过切片，要把该切的图，将其背景都设置透明色，然后在导出用户选择的切片导出。就可以 或者通过雪碧图进行切图 图层的选取（图片一定要是图层）如果图片和图片不再一个图层，先分组，在合并图层，建立选取，复制，新建图层，然后粘贴，然后再三键+s 再另存为png24。 设计稿(切片搞定)1)切片2)通过图片的选取 (图层)出现误操作 通过 历史记录 （窗口面板)参考线 alt+v+D 调出视图的面板 清除参考线ctrl+G 编组ctrl+E 合并图层ctrl 点击图层的空白区域 会出现一个选区ctrl+C 复制选取 ctrl+N 新建图层 ctrl+v 粘贴ctrl+alt+shift+S 另存为 (png24 jpg gif)html fontSize = 设备的尺寸/设计稿 *100 +’px’ 得到的结果会一直动态变化 再或者安装切片工具，利用第三方软件进行切图http://www.cutterman.cn/zh/cutterman 安装切图软件 Swiper移动端的轮播图根据网址http://www.swiper.com.cn/ swiper中文网站http://www.jq22.com/yanshi1176 这个属于案例的网址，可以参考一下。因为swiper引入的轮播图有各种各样的插件，所以在移动端和pc端都可以实现轮播图的添加和制作首先引入html结构1234567891011121314151617&lt;div class=&quot;swiper-container&quot;&gt; &lt;!--图片--&gt; &lt;div class=&quot;swiper-wrapper&quot;&gt; &lt;div class=&quot;swiper-slide&quot;&gt;&lt;img data-src=&quot;images/banner01.jpg&quot; alt=&quot;&quot; class=&quot;swiper-lazy&quot;/&gt;&lt;/div&gt; &lt;div class=&quot;swiper-slide&quot;&gt;&lt;img data-src=&quot;images/banner02.jpg&quot; alt=&quot;&quot; class=&quot;swiper-lazy&quot;/&gt;&lt;/div&gt; &lt;/div&gt; &lt;!--小圆点 分页器--&gt; &lt;div class=&quot;swiper-pagination&quot;&gt;&lt;/div&gt; &lt;!--左右箭头--&gt; &lt;!--&lt;div class=&quot;swiper-button-prev&quot;&gt;&lt;/div&gt;--&gt; &lt;!--&lt;div class=&quot;swiper-button-next&quot;&gt;&lt;/div&gt;--&gt; &lt;!--滚动条--&gt; &lt;div class=&quot;swiper-scrollbar&quot;&gt;&lt;/div&gt;&lt;/div&gt; 在引入css文件1&lt;link rel=&quot;stylesheet&quot; href=&quot;css/swiper.min.css&quot;/&gt; 在引入js文件并且调整js文件的内容，以及结构的布局和安排1234567891011121314151617181920212223242526&lt;script charset=&quot;utf-8&quot; src=&quot;js/swiper.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;// new Swiper(&apos;选择器&apos;,&#123;settings&#125;) var mySwiper=new Swiper(&apos;.swiper-container&apos;,&#123; loop:true, //1oop true 无缝滚动效果 pagination:&apos;.swiper-pagination&apos;, //分页器 paginationType:&apos;bullets&apos;, //分页器的类型 圆点 、分式 1/4、进度条 autoplay:2000, //自动轮播 /* 每次停顿2s钟，以秒来计算*/ speed:1000,/*速度，滑动的速度，1s持续的时间*/ autoplayDisableOnInteraction:false, //用户操作焦点图之后 autoplay 开启// direction : &apos;vertical&apos; //焦点图运行的方向 effect:&apos;coverflow&apos;, //焦点图滑动的效果 fade 渐变 cube coverflow flip、 paginationClickable :true, //点击分页器 控制焦点图 lazyLoading : true, paginationElement:&apos;p&apos;, prevButton:&apos;.swiper-button-prev&apos;, nextButton:&apos;.swiper-button-next&apos;, initialSlide:1//初始的索引值 第二张焦点图// onTouchStart: function(swiper)&#123;// alert(swiper.activeIndex) //2 第1个焦点图 1 centeredSlides: true, //设定为true时，活动块会居中，而不是默认状态下的居左。 slidesPerView: 3, //设置slider容器能够同时显示的slides数量(carousel模式)。 watchActiveIndex: true //监控活动块的索引;设置为true时，拖动slide会即时更新活动块的索引值;默认值: false ，重新初始化时更新。// &#125; &#125;)&lt;/script&gt; 【callbacks 回调函数】onSlideChangeEnd: function(swiper){};回调函数，swiper从一个slide过渡到另一个slide结束时执行。可接受swiper实例作为参数onTransitionEnd: function(swiper){};回调函数，过渡结束时触发，接收Swiper实例作为参数。 【properties swiper函数】mySwiper.activeIndex 返回当前活动块(激活块)的索引;mySwiper.slides 获取Swiper的slides对象数组。通过mySwipe.slides[1]获取特定的slide; 【swiper loop的原理】两个图片无缝衔接,会把第一张放末尾,最后一张放开头,最后的长度在原长度基础上加了2索引值为0 第一个 对应倒数第2张 page(length-2)索引值为length-1 最后一个 对应的第1张 page1其他索引下 正常对应相对应的第几张 写页面时：注意事项REM响应式布局-&gt;我们做的H5页面只在移动端访问(REM不兼容低版本的浏览器) 第一步：从UI设计师拿到设计稿(PSD格式的设计稿) 640*1136 第二步：在样式中给HTML设定一个fontSize的值，我们一般都设置一个方便后面计算的值，例如：10px、100px…这里我们之所以用100px，主要是浏览器最小的字体大小都是12px，用10px比例计算的结果和真实UI设计稿会存在那么一点点的偏差html {font-size: 100px; /1REM=100PX/} 第三步：写页面，写样式完全按照设计稿的尺寸来写样式，此时不用管任何的事情，设计稿给你的宽度、高度、字体大小、margin、padding的值是多少，我们就写多少-&gt;但是我们在写样式值的时候，需要把得到的像素值除以100，计算出对应的REM的值，我们设定的也都是REM的值(值的注意的是：真实项目中外层盒子的宽度我们一般还是不写固定值，沿用流式布局法的思想，我们用百分比的方式布局) 第四步：根据当前屏幕的宽度和设计稿的宽度来计算我们HTML的fontSize的值设计稿:640 600300 fontSize=100 6rem3rem手机:320 300150 fontSize=50手机:375 (375/640)100 -&gt;fontSize=58.59375 351.5625*175.78125 //-&gt;根据当前屏幕宽度和设计稿宽度的比例，动态计算一下当前宽度下的fontSize值应该是多少，如果fontSize的值改变了，之前设定的所有REM单位的值自动会跟着放大或者缩小123456~function () &#123;var desW = 640,winW = document.documentElement.clientWidth,ratio = winW / desW;document.documentElement.style.fontSize = ratio * 100 + &apos;px&apos;;&#125;();","tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"},{"name":"js入门","slug":"js入门","permalink":"http://yoursite.com/tags/js入门/"}]},{"title":"Tagcloud","date":"2017-02-20T07:27:14.000Z","path":"2017/02/20/tags/","text":"","tags":[{"name":"tags","slug":"tags","permalink":"http://yoursite.com/tags/tags/"}]},{"title":"测试代码1","date":"2017-01-22T05:28:09.000Z","path":"2017/01/22/测试代码1/","text":"1111的空间里萨科技风 在哪里就是这样， 还有真的 还有那么是 那是 那是实时的吗？ 在试一下 跟他都没关系 haha","tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"},{"name":"qijiyinqiao","slug":"qijiyinqiao","permalink":"http://yoursite.com/tags/qijiyinqiao/"},{"name":"Another Tag","slug":"Another-Tag","permalink":"http://yoursite.com/tags/Another-Tag/"}]},{"title":"","date":"2017-01-20T12:19:58.000Z","path":"2017/01/20/hello-world/","text":"title: Hello WorldWelcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"Tagcloud","date":"2017-01-20T12:03:03.000Z","path":"2017/01/20/标签/","text":"撒旦法师打发打发第三方","tags":[{"name":"Testing","slug":"Testing","permalink":"http://yoursite.com/tags/Testing/"}]},{"title":"Git搭建博客","date":"2017-01-19T16:00:00.000Z","path":"2017/01/20/git搭建/","text":"hexo博客搭建 今天闲下来想把之前安装hexo博客和换了电脑之后、或则工作中有两台电脑的话，实现一台电脑上传和同步功能，另一台电脑也能够上传和同步功能，这些功能重新再记录一下 搭建本地环境安装git git官方下载地址：http://git-scm.com/download/ 注意安装的时候选择第三项全部适应，其他都是next在Select Components界面，点选Simple context menu 安装完成后，可以git version返回任何版本都代表安装成功 安装node Node.js官方下载地址：https://nodejs.org/ 同样一路next 安装完成后：全局命令符cmd中输入 code -v可以查看node版本 安装hexo 全局命令符中输入npm -install hexo -g 这个是代表在利用npm管理工具全局安装hexo文件 查看安装情况： npm install 安装依赖包；如果有安装可以查看安装的情况 npm install hexo-deployer-git -save 在本地安装一个npm开发的插件，使用hexo d来部署到git上 创建本地仓库 随便创建一个文件夹，hexo init 即会在目标文件夹建立网站所需要的所有文件 开启服务器：hexo s 然后就可以在浏览器输入localhost:4000或者127.0.0.1：4000，可以打开博客的主页 设置user.name和user.email。git config --global user.name “你的GitHub用户名” git config --global user.email “你的GitHub注册邮箱” 创建ssh（公钥和密钥）可以免输入账号和密码 如果只是测试学习可以不用设置 检查是否安装过ssh：ls -al ~/.ssh如果安装过可以$ cd ~/.ssh 或cd .ssh；ls查看所以内容：window：C：Users\\Adminstrator.ssh ;mac的位置： 打开git bash，在用户主目录下运行：ssh-keygen -t rsa -C&quot;youremail@example.com&quot; 把其中的邮件地址换成自己的邮件地址，然后一路回车 最后完成后，会在用户主目录下生成.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH key密钥对，id_rsa是私钥，千万不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 登陆GitHub，打开「Settings」-&gt;「SSH and GPG keys」，然后点击「new SSH key」，填上任意自定义Title，在Key文本框里粘贴公钥id_rsa.pub文件的全部内容（千万不要粘贴成私钥了！），最后点击「Add SSH Key」，你就应该看到已经添加的Key。 检查一下是否安装好了：ssh -T git@github.com然后你输入yes，然后出现hello，用户名表示安装成功 在终端里输入命令：git config --global user.name &quot;username&quot;``git config --global user.email &quot;email&quot;之前设置过就不用设置了 如果添加了以后还需要在这里应用ssh 如果你之前用的是https，那么你就用不了ssh因为你用的是https而不是ssh。你可以更新一下123origingit remote remove origingit remote add origin git@github.com:Username/Your_Repo_Name.git 之后你还需要重新设置track branch，比如：git branch --set-upstream-to=origin/master master对于HTTPS方式，你可以在~/.netrc文件里设定用户名密码，不过这样的风险在于密码是明文存放在这个文件里的，比较容易泄露machine github.comlogin Usernamepassword Password找到window的 变量环境 ：本地的系统属性–》高级–》环境变量–》根据图添加一个就行 123456789101112$ ssh-keygen -t rsa -C \"xxxxxx@yy.com\" #建议填写自己真实有效的邮箱地址Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/xxxx_000/.ssh/id_rsa): #不填直接回车Enter passphrase (empty for no passphrase): #输入密码（可以为空）Enter same passphrase again: #再次确认密码（可以为空）Your identification has been saved in /c/Users/xxxx_000/.ssh/id_rsa. #生成的密钥Your public key has been saved in /c/Users/xxxx_000/.ssh/id_rsa.pub. #生成的公钥The key fingerprint is:e3:51:33:xx:xx:xx:xx:xxx:61:28:83:e2:81 xxxxxx@yy.com*本机已完成ssh key设置，其存放路径为：c:/Users/xxxx_000/.ssh/下。注释：可生成ssh key自定义名称的密钥，默认id_rsa。$ ssh-keygen -t rsa -C \"邮箱地址\" -f ~/.ssh/githug_blog_keys #生成ssh key的名称为githug_blog_keys，慎用容易出现其它异常。 搭建github远程仓库环境搭建远程仓库 注册github官网的账户姓名https://github.com/ 然后然后点击➕号repository；仓库名应该为：用户名.github.io 调试博客主题 到hexo.io网站下，然后点击theme 点击主题名，到达github主题的 页面，拉下面有一个install 下面的网址， 在本地博客的命令行输入 ：git clone 下面的地址 下载主题下载下来 或者直接按照提示安装next主题 在webstom根目录下的config.yml下面吧theme下面的主题更改成 自己安装后的主题名称。然后就会在本地显示了，然后再命令符跟新hexo g 生成静态页面 编辑根目录下的_config.yml文件 分别输入：type:git ;repository: 仓库的地址；branch：master；theme：next 然后再到浏览器刷新网页：（github用户名）.github.io ; 如果能打开，博客基本就搭建好了。 配置主题 先配置主题的根目录 优化主题的内容 比如我跟新完文章之后我就会 hexo d -g发布上去 单电脑搭建完成 双电脑实现操作 如果写的博客不希望别人看见，那么就需要创建一个新的私有仓库，写博客用 有推荐的比如 github（收费）、gitcafe（收费）、bitbucket、oschina、coding、阿里云 我用的是阿里云 我们需要把博客的操作内容，就是makedown文件和一些配置的文件，经常变动的文件上传到私有的仓库，这样别人就看不到了，还有就是只需要上传这些文件（不必全部文件都上传） 这里我需要需要用一个文件.gitignore（忽略文件）忽略文件里面要把不上传的文件都放到这个文件里，如果是mac的话，直接终端创建一个touch .gitignore 然后编辑文件 vim .gitignore 在文件里面输入忽略的文件，如果是win的话，直接创建一个txt文件，名字另存为.gitignore即可 123456789.DS_Store Thumbs.db db.json *.log node_modules/ //然后是文件夹node_modules（在用npm install会重新生成）public/ //public内的文件可以根据source文件夹内容自动生成的，不需要备份.deploy*/ //.deploy_git是hexo默认的.git配置文件夹，不需要同步.git //首先是.git文件，无论是在站点根目录下，还是主题目录下的.git文件，都可以删掉。.deploy_git //.deploy_git文件夹（在使用hexo d时也会重新生成） 然后大写的z连续按2次退出即可 把这个文件放入要上传到私有仓库的文件 12345git init //让这个本地文件变成一个git仓库，如果设置过忽略这一步 git remote add origin &lt;server&gt; //server是安装私有仓库的地址，意思是在远程的仓库中映射到本地的仓库分支origingit add . #添加blog目录下所有文件，注意有个&apos;.&apos;(.gitignore里面声明的文件不在此内) git commit -m &quot;hexo source first add&quot; #添加更新说明 写什么都行git push -u origin master #推送更新到git上 写不写-u都可以 这个时候远程的仓库已经上传成功 这个时候，我换了一台电脑，我的pc，因为想在pc上也能同步我的博客内容，所以我现在需要在pc上先搭建本地的环境，可以按照我最开始写的来安装，安装完成后，在pc上会有一个hexo的初始 1234git init #将目录添加到版本控制系统中 如果有了就忽略 git remote add origin &lt;server&gt; #同上 私有仓库地址git fetch --all #将git上所有文件拉取到本地 git reset --hard origin/master #强制将刚刚同步git云端内容覆盖本地的初始内容 至此，下载文件以及完成，现在呢有一个逻辑，就是 mac在家，pc在公司，mac在家跟新了博客，然后也push到私有仓库了新的内荣，然后我pc在公司，就开始往下拉，（记住要也设置忽略文件，不然你提交到云端的话，就会乱套）然后再编辑，再上传到私有仓库，形成循环 在我新内容往下pull的时候报了一个错commit your changes or stash them before you can merge.我采取的操作是放弃本地修改直接覆盖：git reset --hard ；git pull 1234然后在在公司写完后上传到私有云 git add . #将所有更新的本地文件添加到版本控制系统中git commit -m &apos;更新信息说明&apos; git push 12回到家直接git pull 在开始往上push上传的时候，发现主题上传不上，果断把主题下的.git文件删除后，上传成功了，其实每个文件上.git都可以删除，这个文件只是你文件的一些操作可以ls查看当前文件的隐藏文件，然后ls -al可以查看当前文件下面的内容，然后rm -rf .git error： deployer not found :git 如果是这个报错，说明git 开发模块没有安装执行npm install hexo-deployer-git –save 注意事项:hexo deploy没有反应？ 修改配置文件：_config.yml时，冒号后面没加空格。如何换主题？将主题下载后，放到themes文件夹中即可。例如，下面命令安装next主题：git clone https://github.com/iissnan/hexo-theme-next themes/next。在git bash中切换目录到新拷贝的文件夹里，使用 npm install 命令，进行模块安装。很明显我们这里没用hexo init初始化，因为有的文件我们已经拷贝生成过来了，所以不必用hexo init去整体初始化，如果不慎在此时用了hexo init，则站点的配置文件_config.yml里面内容会被清空使用默认值，所以这一步一定要慎重，不要用hexo init。npm install hexo-generator-sitemap --save为了建立站点地图，需要安装 hexo 命令符hexo deploy 部署hexo generate 生成静态页面hexo clean 清空静态页面hexo server 开启服务hexo clean &amp;&amp; hexo g -s 清除、生成、启动hexo clean &amp;&amp; hexo g -d 清除、生成、部署hexo new “文章标题名”hexo new page “tags” 创建一个文件夹，文件夹里有一个index文件。里面type ：“tags” 参考博客hexo官方文档NexT主题官方文档hexo 下的分类和表签无法显示，怎么解决？手把手教从零开始在GitHub上使用Hexo搭建博客教程(一)Github上搭建Hexo如何跨电脑写作部署方便？Continuous Integration Your Hexo Blog With Travis CI【Hexo+Github】域名和github绑定的问题万网域名+GitHub平台搭建的博客hexo搭建过程","tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"},{"name":"git安装","slug":"git安装","permalink":"http://yoursite.com/tags/git安装/"}]},{"title":"2.4 正则表达式：元字符、作用、分组、Replace","date":"2016-10-07T16:00:00.000Z","path":"2016/10/08/2.4 正则/","text":"知识点 正则需要做判断，用在表单元素中输入的不符合标准定义、用在注册，输入的不符合规范，规则过不去的提示。 match、replace和正则表达式一起用 通俗讲在两个斜杠中间放任何一个字符都叫正则 获得焦点，当准备输入一个input文本框的时候，文本框输入光标，onfocus：获得焦点； onblur：失去焦点；失去焦点后判断是否输入正确，value属性，就是获取到输入到文本框的内容 arguments是你传给我的所有的东西 input获得焦点 光标 onfocus 失去焦点 onblur 在[ ]里面的^是非的意思[^?=&amp;]的意思是，除了？=&amp;这三个字符，其他任意一个就行 exec捕获非常重要：reg =/\\d+(\\w)?/ str=”123abc…” 这样第一项是 123abc 第二项是a input是123abc… ； 第一项是123a；第一项是正则显示啥给啥，第二项是正则要啥给啥，input是管你正则是啥，字符串的内容全给我拿过来 正则用法（场景） test验证字符串是否符合正则指定的规则==》注册输入用户名密码都需要符合规则的==》返回布尔值 exec把符合规则的字符串部分从字符串捕获==》比如从名字中获取到姓 把符合规则的字符串拿出来 正则基本就是操作字符串的 验证：reg.test（&quot; 验证字符串&quot;） 捕获：reg.exec(&quot;捕获字符串&quot;) 声明一个正则 var reg =/ a/ 字面量创建方式 var reg =new RegExp 实例创建方式 ，一般正则中出现变量的话用实例的方式创建 常用的元字符 \\d ：0-9之间的任意一个数字 （超过1个也可以） 只要字符串有一个数字就行，不在乎位置 \\d\\d ：必须有两个连续出现的数字 \\d+：1到多位，最少1位 \\a\\i： a可以是任意字母，i是忽略前面字母的大小写 \\w ：代表数字、字母（大小写）、下划线其中的一个 0-9 a-z A-Z _ 代表这些，也是数字字母下划线中的一个，也是一个 \\w\\d ：表示数字必须在数字字母下划线后面；如果是 /1owueroqiwr/ 数字在前面就不行，因为前面是数字字母下划线，后面是数字，不能把顺序弄乱 /1owuer4oqiwr/这个就可以，前面不符合，中间符合就行 \\s ：空格或者空白 在字符串中有一个空格按键就行（一个或多个以上），tab也行 \\b ： 边界==所谓的边界就是 字符串的开始和结束，一些特殊字符的两边也是边界（字符串的两头都是 一个边界，空格 、-、%、也是一个边界；而且他不占位置） \\n ：匹配一个换行，在字符串中是换行的功能==打印’a\\nb’； 回归他本来的意思 则需要’a\\nb’ . ：匹配任意字符，除了\\n（空字符串什么都没有是false） ^ ： 以什么开始 当我对字符串的^$长度有限制的话，就可以加上， $ ： 以什么结束 如果^$ 同时出现，对于这个字符串的个数就限制了（会让正则更严谨） 对位数有限制需要加 ctrl+doller \\.： &quot;.&quot;代表它本身 单一个\\属于转译，代表它本身，不加\\就属于任意字符了 \\ ： 转义多添加一个\\就行==》把特殊意义的字符转变成本来的意思 \\D ： 除了\\d （小d）其他的所有字符，如果加上\\d 小d那就全部匹配了。 \\W ：除了\\w 除了字符串、字母，数字意外的其他字符 \\S ： 除了\\s 除空格以外的其他字符 量词：位置：放在要修饰元字符的后面==》修饰前面的元字符出现的次数 +：1到多个 至少1个 \\d+代表最少1个字符，最多没限制 *：0到多个 可以有，可以没有 ， 0次代表没有 ？：0-1个 要么出现，要么不出现， ？ 代表有没有都行 ?:：匹配不捕获，能够破坏分租，因为exec获取的小括号内容，它一存在就破坏分组，然后就获取不到了； {n}：出现n个 {n}在后面表示前面的元素连续出现几次 {n,}: 至少n个 最少n个 {n,m}: 出现n到m个 {1,16}最少1位，最多16位 正则中的或者 [ ]、 | x|y ： x或者y中的一个 x|y|z 由于或者关系是满足其中一个就可以，所以处理或者关系的时候我们不妨用()去改变运算的优先级 |：或者的意思：一条数线 满足一个条件即可 [xyz]： x或者y或者z中的一个 字符串中只要有一个就行了 中括号里面等于或者的意思 [^xyz]： ^是非的意思：只要字符串中 有一个字符 不是x 不是y 也不是z 就为true； &#39;axyz &#39; ：true：字符串中只有xyz；&#39;xyzxyzyyz&#39;为false ；这个方法要求字符绝对纯净，只能有xyz，只要有任何其他数都是true就是不纯净，当然只有xyz的话，就是false [+ -]：&#39;+&#39;或者&#39;-&#39;中的 一个 只要字符串中出现任意一个就行，中间空格代表或者的意思 [\\d\\w]： 数字，字母，下划线中的任意一个 \\w：[0-9a-zA-Z_]其中一个就可以 [0-9a-zA-Z_]：这里的-在[ ]表示 到 的意思 [.]：中括号中的&#39;.&#39;代表的不是任意字符，代表&#39;.&#39;本身 举例： ^ $ /^18|19$/ 如果不加括号的话就是 ‘18lksdlfk’ ‘191283919’这两个都满足，如果要满足规则需要加一个括号 /^(18|19)$/由于或者关系满足其中的一个就可以，所以处理或者关系的时候，我们不妨使用（）去改变运算的优先级，把这一部分看做是一个整体 123456789// 简单的有效数字验证 ??? // +5 5 -5 0.5 0.05 0.005 +0.005 -0.005 55.5 -5555.5555 var reg = /^[+-]?\\d+(\\.\\d+)?$/; console.log(reg.test(\"0.555\"));//简单邮箱验证 281cngbai@sina.com.cn var reg = /^\\w&#123;1,16&#125;@[0-9a-zA-Z]&#123;2,20&#125;(\\.[a-zA-Z]&#123;2,3&#125;)&#123;1,2&#125;$/;//身份证 \"2112 24(1986)(0210)82(1)0\"; // =&gt; 数据库收集 birthday : 括号1 gender性别 : 括号3 var reg = /^\\d&#123;17&#125;(\\d|X)$/; // 整个身份证号的匹配，exec 12345678910// 非空验证 输入框如果为空弹窗提示 var reg = /^\\s*$/; // 必须记住 var input = document.getElementById('input'); // 获得焦点 光标 onfocus // 失去焦点 onblur input.onblur = function ()&#123; // 失去焦点判断是否输入 //console.log(this.value); // value属性就是获取的输入到文本框的内容 if(reg.test(this.value))&#123; alert('输入不能为空'); &#125; &#125; 正则–创建方式与区别（2）实例和字面量的区别，字面量用的多 如果使用实例的创建方式创建，特殊的元字符\\d需要在创建的时候，需要在前面在new RegExp加一个&#39;\\&#39;（\\d） 实例创建，在new的过程中的第二个参数就是修饰符 只要正则中有需要变量的时刻，那么就只能使用实例的创建方式 修饰符： /\\d/i =&gt; 匹配的时候忽略大小写 i：ignoreCase 在匹配的时候，忽略大小写 m：multiline 多行匹配 g：global 全局全文 （一般用于捕获exec） 用的比较多 1234//第二小点 var reg = /a/i; // i修饰符，表示忽略大小写； var reg = new RegExp('\\\\d',\"i\"); // 特殊元字符创建方式，第二个字符为修饰符 console.log(reg.test('6')); 1234567//第三小点 var name = 'cb'; var reg1 = /name/; // name就是name，不是变量 console.log(reg1.test('name')); // true，输入的就是name var reg2 = new RegExp(name,'i'); console.log(reg2.test('name')); // false，匹配的时候不能匹配变量，如果后面的值为\"cb\"的话，匹配的结果为true exec捕获方法（3）正则就2个方法，一个是test测试、匹配 一个是exec捕获 exec 捕获结果 返回一个数组 [正则捕获回来的结果 、 index: 捕获开始位置的索引, input : 原有字符串 ] reg.lastIndex 属性==》下一个捕获从哪个索引位置开始，当捕获结果为null这个属性值就会重新赋值为0；然后就又从开始捕获了 Match: 也是捕获的意思，找到要找的字符，返回数组[内容、索引、原字符串]，找不到返回null， 返回一个数组 会把所有符合要求的一次性捕获回来 123456789101112131415 var reg1 = /\\d+/g; var str = \"cb2017xyz20000\"; var result = reg1.exec(str); // [2017, index: input : ] var ary = []; while (result)&#123; // result : [2017],[20000],null 每次循环都是按照在字符串中的规则进行捕获的，第一遍结束返回null为false跳出循环体 ary.push(result[0]);//每次都把第一项放到数组里面 console.log(ary); result = reg1.exec(str); // [20000,index : input: ] 第二次捕获的第二项规则数字 &#125; console.log(ary); // [2017,20000]//match var str2 = 'a222b333'; var reg2 = /\\d+/g; var res2 = str2.match(reg2); console.log(res2);// [222,333] 正则中的分组和分组的引用？的用法 ？ ： 代表一个量词 0-1次 （？:\\d...） ：放在一个分组的开头，匹配不捕获，破坏分租的功能呢； 把这个分租给去掉,小括号还在，不捕获了，只匹配不捕获， 分组概念：想获取到字符串中的一部分那么可以使用分租 ==》在大正则中使用小括号 所谓的分租就是 在正则里面加小括号，这样用捕获就可以拿到了。 分组影响捕获结果 : exec捕获返回的结果是数组，第一项是雷打不动的数组，从第二项开始分别是分组捕获到的内容倒数第二项是index索引序号，倒数第一项是input原数组 ps : 括号从左到右依次出现的顺序作为分组顺序 RegExp.$9 保存着正则实例最后一次被使用的分组的内容 RegExp.$？ $符后面保存着正则捕获到的小括号里的排列。1位第一位小括号。2位第二位小括号 分组的引用 : 当后面出现的字符需要和前面保持一致时；需要用到分组的引用 例如abab aabb 1234var id = '211224198602108210';var reg = /^\\d&#123;6&#125;(\\d&#123;4&#125;)\\d&#123;6&#125;(\\d)(?:\\d|X)$/;//最后一项只匹配不捕获console.log(reg.exec(id));// [[\"211224198602108210\", \"1986\", \"1\", index: 0, input: \"211224198602108210\"]] 12345678910111213var reg = /(\\d)\\1\\1\\1/; // 分组的引用console.log(reg.test('15011113838')); //truevar reg = /(\\d)(\\d)\\1\\2/; // ababconsole.log(reg.test('9393'));//truevar reg = /(\\d)\\1(\\d)\\2/; // ababconsole.log(reg.test('1122'));//truevar reg = /(\\w)(\\w)/;console.log(reg.exec(\"ax\"));reg.__proto__.constructor.x2 = reg.exec(\"ax\")[2];//第0项为ax ，第一项为a，第二项为x，前面只是x2只是正则累的一个属性// RegExpconsole.log(RegExp.$2); //x $符后面保存着正则捕获到的小括号里的排列。1为a；第一位小括号。2为x；第二位小括号的内容，没有第0位和第三位，因为只捕获了2个 验证的时候基本上不用g split的用法： split的参数可以是一个正则，拆分字符串的时候会把正则匹配到的位置，全部拆分，split返回为数组 123var str = 'a b-c d'; var res = str.split(/[ -]/); console.log(res); // [a,b,c,d] Replace用法： replace会返回一个新的替换好的字符串，str=str.replace( ) 如果第二个参数是一个函数，则这个函数的返回值return来替换第一个参数所匹配到的内容，===》函数执行的次数取决于第一个参数正则成功匹配的次数 第二个参数函数中的arguments：[ 总正则在当次执行匹配到的内容，从第二项开始分别是分组n….，倒数第二是index索引序号，第一项是input 原字符串] 当第二个参数是$1字符串，如果有分租那么代表就是分租1，没有$0的数字，只有1-9，分组1-分组9 用$+(1-9)来计算出最后的捕获内容12345678var str = 'wo2018ai2017beijing'; //str = str.replace('zwo,'我'); var reg = /(\\d+)/g; str = str.replace(reg,function (res,$1,index,input)&#123; console.log(arguments); // 分别为2次结果，主要是正则的规则在字符串中能够匹配到2次不同的要求；[\"2018\", \"2018\", 3, \"wo18ai201beijin\"] [\"2017\", \"2017\", 11, \"wo2018ai20beijin\"] argunment[?]第一项为匹配到的内容，第二项为分组输出的内容。后面分别是index序号和input原字符串 return '主'; &#125;); console.log(str);//wo主ai主beijing 用Replace实现数字转大写字母 1234567891011 var str = 'abcdefg'; // 遍历字符串 str.replace(/(\\w)/g,function ()&#123;//加了g就是全局全文，把整个str里的内容都循环一遍，不加g的话，只循环依次，只找到第一个符合的就行 console.log(arguments[1])//第一次为a，第二次为b，第三次为c... &#125;);//将数字全部都转换成大写 var str = '1324134'; //=&gt; \"伍叁壹贰肆\" 随便写随便换 var str1 = '零壹贰叁肆伍陆柒捌玖'; str = str.replace(/\\d/g,function ()&#123; return str1.charAt(arguments[0]); //根据括号里的索引找str1里的字符，第一次arugument[0]为数字1找到str1中的壹；由于是循环加替换，会循环str里的每一项符合正则规则的字符，然后依次进行replace替换，将替换好的数组返回。 5 =&gt; '伍' 4 =&gt; '肆' &#125;); console.log(str); Replace最后替换出来是一组新数组，一定要进行重新复制，或者新变量接受才可以展示。12345678var str = '2015beijing';var reg = /(\\d+)/g;//全局全文找一段数字str = str.replace(reg,'$1'+'￥');console.log(str)//2015￥beijingstr = str.replace(reg,function ()&#123;//切记replace替换回来的是一个新数组，所以一定要记住有一个变量接受他，不然console不出来 return '￥'+arguments[1] + '￥112';//￥2015￥112￥beijing&#125;);console.log(str); Replace例子：如何找出一个字符串中出现最多的字符 ,出现几次12345678910111213141516171819202122232425262728293031var ary = [1,2,3,3,2,1,2,3]; // 数组中出现最多的项，出现几次?? var obj = &#123;&#125;; // &#123; a : 3,b : 2, c : 2 , d : 2&#125; var str = 'aabbccdda'; //如何找出一个字符串中出现最多的字符 ,出现几次 str.replace(/\\w/g,function ()&#123; arguments[0]; // a a b b ... console.log(arguments[0]); if(obj[arguments[0]])&#123; // obj.a 第一次 undefined obj[arguments[0]] += 1;//如果这个数存在，就让它的值在原有的基础上+1， &#125;else&#123; obj[arguments[0]] = 1;//如果他不存在，就让他的属性值=1 &#125; &#125;); console.log(obj); // &#123; a : 3,b : 2, c : 2 , d : 2&#125; //求最多的那一项出现几次 var max = 0;// for(var key in obj)&#123;//循环这个对象的每一组键值对 if(obj[key] &gt; max)&#123;//如果obj的属性值大于0的话， max = obj[key];//就把obj的属性名对应的属性值给max，再继续循环，此时的max为3，那其他的属性值进行对比 &#125; &#125; console.log(max); // 3 =&gt; ??? //求出现最多的那一项是哪一项 var ary = []; for(var key in obj)&#123; if(obj[key] == max)&#123;//现在的max=3了，如果obj的属性名对应的属性值=3的话，就把这个属性名给ary这个空数组 ary.push(key); &#125; &#125; console.log(ary);//空数组输出的是属性值为3的a 简单的模板引擎实现原理 1234567891011var template = '&#123;0&#125;年&#123;1&#125;月&#123;2&#125;日，&#123;3&#125;点&#123;4&#125;分&#123;5&#125;秒'; // 时间格式模板// ary[0] 1 2 3 4 5var str1 = '2017-03-05 18:24:40'; // 替换成如上的格式var ary = str1.split(/[- :]/);//ary : [2017,03,05,18,24,40]var reg = /&#123;(\\d)&#125;/g;//全局里面找一个类型的数字，加了g就是全局接着顺序找，不加g的话造成每次只找数字就行了，那就只能找到第一个数，你不是说只要数字么。又没跟我说在在全局全文按照顺序找。var res = template.replace(reg,function ()&#123;//replace前面是大环境，大环境说了自己的环境里有一些旧的东西需要替换，找到replace，repalce有两个门，括号里是规则，过滤器，第二个是要替换的容器，容器里面会return出来一个数和规则要求大环境里面的哪个数来进行替换 console.log(arguments);// aruguments是什么？arguments是既然要替换，你就必须告诉我，替换哪些东西，哪些旧的准备要替换的字符，你一个一个的都给我。这是我的集合，第一次给的是一个 [\"&#123;0&#125;\", \"0\", 索引, \"&#123;0&#125;年&#123;1&#125;月&#123;2&#125;日，&#123;3&#125;点&#123;4&#125;分&#123;5&#125;秒\"] 第二次$1又是索引2，不凑巧给的都是索引，我好根据索引来在我这边拿数 return ary[arguments[1]];//由于大环境中的数字就是按照索引来排序的，所以直接拿ary数组中的数字，来替换掉大环境中的数字&#125;);console.log(res);","tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"},{"name":"js入门","slug":"js入门","permalink":"http://yoursite.com/tags/js入门/"}]},{"title":"2.3 小练习产品排序、表格排序","date":"2016-10-06T16:00:00.000Z","path":"2016/10/07/2.3 实战表格排序/","text":"知识点 git问题，如果遇到自己修改了git clone 下来的文件，导致再次跟新跟新不了的情况下，可以使用强制跟新git reset --hard git pull origin master 数据库中，只有两个值的时候，就是0和1，比如说性别，男1，女0 有变量惨进来的属性名，必须要用中括号 去掉table上的小白线：cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; 1是升序 -1是降序，让sort排序里的值乘以-1，就可以重新排列 -webkit-user-select: none;点击的时候，文字不被选中，css样式 京东的产品排序 先将html和css在页面中写了 开始写js—创建一个文件夹js—然后创建一个js文件—在html中src引用js文件，开始写js文件： 首先先获取要操作的元素利用ID 、Tagname、Classname 12345//先获取最外层的id ，其他的都是它里面的内容var product = document.getElementById('product');var btn = product.getElementsByTagName('a');//包含价格和成交量的按钮var ul = product.getElementsByTagName('ul')[0];var lis = ul.getElementsByTagName('li'); （ajax）接下来需要获取后台的数据，再把获取到的数据添加到页面中 new XMLHttpRequest( )创建一个异步对象（到后台拿数据） xhr.open(get/post,url,true/false)打开一个描述 get/post : 请求方式 url : 接口 (后台提供) true/false : 同步/异步 同步原地死等 异步多任务 xhr.onreadystatechange = function 当readystate状态改变触发函数 if(xhr.readyState == 4 &amp;&amp; xhr.status == 200){判断条件 xhr.readyState == 4 代表xhr回来了 xhr.status == 200 代表成功获取到数据 date = JSON.parse(xhr.responseText) 这个属性保存着从接口获取回来的数据 xhr.send(null)发送执行 因为没有后台数据，现在我们需要mock 一个数据，简单说是自己造一个假数据 123[ &#123;&quot;src&quot; : &quot;images/phone9.jpg&quot;, &quot;price&quot; : 199, &quot;comment&quot; : 10089 &#125;]//这个是data.txt文件中的数据，数据会根据不用的网页需求，制作不同类型的数据 将获取到的数据添加到页面中 ==》 1. 动态添加 2. innerHTML的方式添加 1. 动态添加方法： 2. appendChild （）`appendchild（动态添加）`的方式不会影响元素的任何属性，曾经绑定过的方法现在还存在 3. innerBefore（） 采用innerHTML的方式将从数据库中获取的数据添加到页面中 123456789101112131415;(function bindData()&#123;//自执行函数 if(data &amp;&amp; data.length)&#123; // 如果data存在并且data.length也存在 if判断真假 var str = '';//添加一个空字符串 // data : [&#123;src : \"images/phone1.jpg\", price : 8888, comment : 23 &#125;...] 自己moke的数据 for(var i = 0; i &lt; data.length; i++)&#123; //便利数据中的每一项 var curData = data[i]; // 每次循环的当前对象 str += '&lt;li price=\"' + data[i].price + '\" ok=\"' + data[i].ok + '\"&gt;'; str += '&lt;div&gt;&lt;img src=\"'+ curData.src +'\" &gt;&lt;/div&gt;';//只是将自己的数据引用到字符串的变量中curDate.src再字符串拼接 str += '&lt;p class=\"price\"&gt;&lt;i&gt;￥&lt;/i&gt;'+ curData['price'] +'&lt;/p&gt;'; str += '&lt;p class=\"comment\"&gt;&lt;i&gt;'+ curData['comment'] +'&lt;/i&gt;人评论&lt;/p&gt;'; str += '&lt;/li&gt;'; &#125; productList.innerHTML = str;//拼接好以后，最后再输出到ul中，由于dom映射非常强大，所以拼接好的字符串中的方法都会被应用起来 &#125;&#125;)(); 给上面两个按钮添加点击事件123456789101112131415161718192021222324for (var i = 0; i &lt; btn.length; i++) &#123;//循环那两个按钮 btn[i].flag = -1;//添加属性名为flag，属性名为-1 btn[i].onclick = function () &#123;//当当前的按钮触发点击事件的时候开始排序 sort.call(this)//，如果没有this，sort执行的时候，sort里函数的this是window，所以需要给sort里的this改成当前点击事件的主体； &#125;&#125;//sort排序，将产品进行排序并放到大的ul当中。function sort() &#123; var btnName = this.getAttribute('btnName');//获取当前点击主体的属性名为btnname的属性值&#123;ok，price&#125; var lisary = Array.prototype.slice.call(lis);//lis为类数组，不具备数组的功能，需要通过数组中的slice方法，将类数组转化成数组，使用数组的方法 var that = this; that.flag *= -1;//让每次执行sort的时候，this的属性名都乘以-1，乘以-1可以使排序的方向对调一下 lisary.sort(function (a, b) &#123;//将数组li进行排序 var x = a.getAttribute(btnName);//当前这个是btnName不是ok就是price，就看点击的时候点击按钮自带的的是ok属性还是 price属性。 var y = b.getAttribute(btnName);//由于在上面字符串拼接中在li这个行内样式将ok和price的属性也一起拼接到了li的行内属性中，所以在这里直接调用li的getAttribute这个行内样式的属性名的属性值就行， return (x - y) * that.flag;//将li行内样式的属性名的属性值算出来赋值给x和y，这两个都是数字所以可以进行相减。 &#125;) var frg = document.createDocumentFragment(); for(var i=0;i&lt;lisary.length;i++)&#123;//循环排好序的每一项 frg.appendChild(lisary[i]);//将每一项都放到文档碎片当中。 &#125; ul.appendChild(frg)//再讲碎片放到ul这个大盒子中。 frg=null&#125; 国家统计信息–表格排序 获取要操作的元素 1234567var table = document.getElementById('table');var tHead = table.tHead;var row = tHead.rows[0];var ths = row.cells;//获取这个行的每一列、每一个单元格var tBody = table.tBodies[0];var tBodyRows = tBody.rows;//获取这个大body的每一行 ajax引入数据（4步） 123456789;(function () &#123;//包一个自运行函数可以使函数里的变量安全，是闭包的作用，不被外界的打扰 var xhr = new XMLHttpRequest();//创建一个这个类的实例，记住这个类 xhr.open('get', 'data.txt', false);//打开一个描述，获取方式、地址、是否同步 xhr.onreadystatechange = function () &#123;//当状态发生改变之后操作 if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123;//前一个值返回4说明，后一个值为200时，代表成功获取到 window.data = JSON.parse(xhr.responseText)//将获取到的数据存放在data里面，因为是字符串，需要转出JSON专有对象格式 &#125; &#125;; xhr.send()//立即执行&#125;)(); console.log(window.data); 把数据输出到页面中使用动态创建的方式，回头再用innerHTML的方式 1234567891011121314151617;(function()&#123;if (window.data &amp;&amp; window.data.length) &#123;//如果data存在，并且数据的长度也存在，那么继续执行 var frg = document.createDocumentFragment();//创建一个文档碎片 for (var i = 0; i &lt; data.length; i++) &#123;//循环数据中的每一项 var tr = document.createElement('tr');//创建一个tr元素，就是tr标签元素 for (var key in data[i]) &#123;//再循环数据中每一条中的每一个属性 var td = document.createElement('td');//创建一个td的标签元素 td.innerHTML = key == 'develop' ? data[i][key] ? '发达' : '发展中' : data[i][key];//三元运算符套三元运算符， //第一个判断是如果是key属性名为develop的时候执行？？？如果不是的话将所有的属性塞到td标签元素中 //第二个判断是在第一个判断基础中，前提是develop的话，如果是正确的就是true是1的时候就是‘发达’，如果是false布尔判断是0的话，就是‘发展中’ tr.appendChild(td);//塞到tr标签元素中 &#125;; frg.appendChild(tr);//tr元素的内容塞到frg文档碎片中 &#125; tBody.appendChild(frg);//frg文档碎片塞到tbody这个大盒子中 frg=null&#125; &#125;)(); 隔行变色 1234567function changebg ()&#123;//创建函数，以后可能会调用 for(var i=0;i&lt;tBodyRows.length;i++)&#123;//便利大body中的每一行 tBodyRows[i].className = i%2? 'c1':'c2';//两种方式都行 tBodyRows[i].className = 'c'+i%2 //常亮加引号，变量不用加 &#125;&#125;changebg()//执行隔行变色 给表头添加点击事件 123456789for(var i=0;i&lt;ths.length;i++)&#123;//首先循环表头中的每一项 ths[i].index=i;//表头中的第i项添加一个属性，属性值为i，保存索引用来传给sort作为排序依据 ths[i].flag=-1;//表头中的第i项添加一个属性，属性值为-1，用来执行升序和降序切换的时候使用 if(ths[i].className=='cursor')&#123;//这个添加了一个类名，考虑到某些列项不需要点击，所以给需要点击的列项添加了类名 ths[i].onclick=function()&#123; sort.call(this,this.index);//一开始直接sort（）执行就可以了，但是现在需要用到事件函数中的this，所以需要把函数执行中的this替换成当前点击项，这样函数执行的时候，函数中的this就是 当前的点击函数。还有就是必须要传值，保证排序能够正常进行 changebg()//由于背景是跟着当前的li，如果不添加的话，排序的时候很容易不遵循隔行变色，所以这里添加的意思是，只有点击的时候才执行隔行变色功能。 //由于appendChild不会破坏元素上的属性，所以排序不执行隔行变色的时候，属性会跟着内容走，因为排序是根据内容排的。 &#125; &#125; &#125; 排序 123456789101112131415161718192021222324function sort (n)&#123;//这一步是最后一步的执行，详情见第五步 for(var i=0;i&lt;ths.length;i++)&#123; if(ths[i]!=this)&#123; ths[i].flag=-1; &#125; &#125; --- this.flag*=-1//第三部设置-1是为了让点击的时候每次都乘以-1，保证切换 var that =this;//因为this在函数中，this肯定会改变，所以赋值给that就可以使用that来调用this的功能 var tBodyAry = [].slice.call(tBodyRows);//排序需要先把td获取到的类数组转化成数组才能使用数组方法 tBodyAry.sort(function(a,b)&#123;//执行sort方法 var x = a.cells[that.index].innerHTML;//使用cells获取a这行中的每一个单元格，后面紧跟所以值，之前有设置过自定义属性，所以所以就是当前循环数i，。innerHTML是：将a这一行中索引为i的单元格在页面中**显示的内容**，赋值给x var y = b.cells[that.index].innerHTML; if(isNaN(x)||isNaN(y))&#123;//判断是数字还是汉字 如果不是一个数，返回true return x.localeCompare(y)*that.flag;//如果不是一个数，就按汉字的拼音首字母来从小到大排序 &#125;else&#123; return(x-y)*that.flag;//如果是数字就按减法来排序，每次点击都*-1，**-1位降序，1位升序**，每次都*-1，每次点击值都会发生改变 &#125; &#125;); // return a.cells[n].innerHTML-b.cells[n].innerHTML; 这是 最初的模型，如果都是数字的就简单了。 for(var i=0;i&lt;tBodyAry.length;i++)&#123;//便利tbody中的每一行 tBody.appendChild(tBodyAry[i])//将每一行添加到tbody的末尾 &#125;&#125;//以上内容好好记一下，可以的话记得背下来 由于排序稍显复杂，可以分成每一小步来执行观察，方便理解//1. 第一步先让数字的一列执行从小到大排列//2. 第二步再让数字的一列从小到大的排列//3. 第三部我加入了一个判断，如果再页面中是汉字的话，就让他按字母排列，如果是数字的话就按从小到大排列//4. 第四步我打算让点完升序，还想再点的时候实现降序的功能，我用的是在sort末尾乘以-1实现，每次点击都变换，默认-1为降序，1是降序//5. 第五步我还想实现点这一项的时候，再点其他项的时候由升序来排列。（这样不管你那一项离开本项都是升序排列）","tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"},{"name":"js入门","slug":"js入门","permalink":"http://yoursite.com/tags/js入门/"}]},{"title":"2.2 dom映射、json数据格式","date":"2016-10-04T16:00:00.000Z","path":"2016/10/05/2.2 dom映射/","text":"知识点 类数组 ：lis[li,li,li,li]、arguments 元素集合，类数组集合 HTML Collection 数组集合：任然和页面内的li元素存在这种一一对应的关系，我们叫这种关系叫做dom映射 LocaleCompare，按照字母的排列排序 只要循环体中套事件函数，就不要用这个 i（循环的变量） 因为你要用这个i这个i已经循环到最大值 循环嵌套事件函数中的i值，会报错，因为这是的i已经是最大值了，所以，下次循环中嵌套事件函数中，要记得用this来代替当前的事件函数 这个循环结束之后，每个li 的onmouseover和onmouseout属性都被赋值一个函数 try，catch只有在判断有报错的情况下用这个方法，相当于if else In是判断一个运算符是不是一个对象的属性；“setInterval” in window 判断一个属性是否属于一个对象， 返回一个布尔值；共有属性和私有属性都可以判断；判断属性名字要用字符串， ‘JSON’ in window debugger：断点调试，在控制台Sources 打个断点，就是查看循环每次的时候，每一次的变化，也可以查看函数或者其他代码执行到每一步的情况按f11也是 任何一个引用数据类型if判断都是真的 undefined是fasle 自己mork的数据之文本型文件都是字符串 localhost：63342 代表本地端口为63342 &lt;li price=&quot;2&quot;&gt; get arrtibute获取这个属性值 Array.prototype.slice.call(list,0)这个是通过array.原型找到这个slice方法，如果不是数组就找不到这个方法，也可以是一个[ ]，数组也有slice方法，最后利用call方法改掉slice方法里的this，而这个this是slice这个方法的实例，所以把实例改成list，最后克隆一份list出来。 创建文档碎片的目的是为了减少dom回流，考虑到了性能方向的问题。 如果之前的元素上面绑定方法和属性，就可以用inneriHTML的方式和字符串拼接的方式来用，这个方式会破坏原有元素的属性，所以不存在任何元素的时候可以用这个方法。 如果用appendChild的方式可以保证原有的方式不被破坏，动态创建的方式并不会原来元素的属性，但是操作起来不便，还有可能引起多次回流。 造假数据的过程叫做mork indexOf lastIndexOf 根据索引找字符，找不到-1 直接添加到行内属性的，就是获取行内属性，需要用get attribute 这种属性 window.navigator.userAgent属性包含了浏览器类型、版本、操作系统类型、浏览器引擎类型等信息，通过这个属性来判断浏览器类型。 Dom映射什么是dom映射页面中的元素，通过dom方法，获取回来的集合，这个集合任然和页面中的元素存在这种一一对应的关系 就是dom映射 。并且即使这个元素暂时不存在，那么这个变量lis集合任然会随着页面内li的增加而增加，减少而减少 12345678910// 通过dom方法获取回来的集合console.log(lis); // HTMLCollection 类数组集合// 把集合转化成数组，为了使用数组中的方法var lisAry = utils.listToArray(lis); //调用已经封装好的函数utilsconsole.log(lisAry); // 数组集合 =&gt; 仍然和页面内的li元素存在这种一一对应关系// 把数组排序lisAry.sort(function (a,b)&#123; // a、b相邻两个数，localeCompare根据首字母排列 return a.innerHTML - b.innerHTML;&#125;);console.log(lisAry);//输出排序好的数组 排序方法： 页面中的元素先获取到，dom方式获取回来，得到一个类数组 元素转数组，因为没有排序方法 排序 送回去，不是多出来，只是改变他的位置 我想在这插入一个类数组转数组的方法 12345678910111213var utils=&#123; listtoArray : function(list)&#123;//属性名为listtoArray，形参为list try&#123; //把slice方法中的this修改成了list数组，因为slice中的this就都是克隆的那个数组，把this改成list后，就变成了克隆list并且返回，ie8以下都不兼容 //打个比方：ary.slice() 相当于克隆了一份ary // 然后 ary.slice.call(list)相当于把ary和list进行的替换，然后克隆了一份list出来，返回的就是数组 Array.prototype.slice.call(list,0)//由于在ie中不兼容，所以先尝试执行这里的代码，如果执行报错，再执行catch里面的代码 &#125;catch(e)&#123;//catch里面的e是上面报错的话，下面的e可以打印出上面报什么错 console.log(e.massage)//e.massage保存着报错的信息 js中容错机制，（对错误的处理）其实就是把报错的信息，打印出来，没有红色的×了。 var ary =[]; for(var i=0;i&lt;list.length;i++)&#123; ary.push(list[i]) &#125; return ary &#125; &#125; &#125; 循环把已经排序好的这些li重新添加到页面中 =&gt; 页面中多了元素还是原有元素调换位置?? document.createDocumentFragment(); 创建一个文档碎片 debugger：断点调试，在控制台Sources 打个断点，就是查看循环每次的时候，每一次的变化，也可以查看函数或者其他代码执行到每一步的情况 dom映射：页面中的元素，通过dom方法获取到的集合，集合任然和页面中的元素存在一一对应关系，我们把这关系叫做，dom映射 dom回流：页面中元素位置的改变，或者元素的增加和删除，都会引起dom回流；简单来说就是 就是少了挤上去，多了撑出来dom回流相对于dom重绘更耗费性能 dom重绘： 页面中的元素样式的改变会引起重绘单个元素改样式===&gt;：尽量去避免回流，因为相对重绘而言，回流更耗性能， 文档碎片：简单来说就是一个dom容器；简单说来就是创建一个临时的dom容器，先在这个容器里调试成功后，将新增加的元素并不会影响原有li的事件，在和页面中的原有元素进行替换，减少dom回流，也为了减少性能，利用完文档碎片后，记得主动释放文档碎片空间 模板引擎：在真正开发的时候，动态创建和innerHTML用的都少，用的多的是模板引擎；只要有了模板直接换对应的数据就可以了，详细见上一章 12345678var frg = document.createDocumentFragment(); // 创建一个文档碎片，dom临时容器 for(var i = 0; i &lt; lisAry.length; i++)&#123;//循环数组中的每一项 //debugger; 利用这个断点调试 //list.appendChild(lisAry[i]); // 按理说应该把这些li添加到list中，但是可能会照成dom回流 frg.appendChild(lisAry[i]); // 暂时先把这些li添加到文档碎片中 &#125; list.appendChild(frg); // 把包含所有 li的文档碎片添加到list列表中，减少dom回流，和减少性能 frg = null; // 主动释放文档碎片 经过验证：是把原有元素重新调换位置 ； 那些增加的属性onmouseover和onmouseout还有xxxx属性还存在不?? =&gt;存在 说明使用appendChild(动态添加)的方式不会影响元素的任何属性,曾经绑定过的事件现在还存在1234567// 我想在页面中原有的基础上增加4个 // 第一个种方法（动态创建） for(var i = 5; i &lt;= 8; i++)&#123;//因为前面已经有4项，可以先从第五项开始设置 var li = document.createElement('li');//动态创建一个li标签元素 li.innerHTML = i;//在li这个元素标签中添加i数字 list.appendChild(li);//将li添加到list这个元素集合中 &#125; 1234567//第二种方法： innerHTML的方式 =&gt; 会破坏原有元素的属性。 var str = ''; for(var i = 9; i &lt;= 10; i++)&#123;//上面用动态创建过5-8 str += '&lt;li&gt;' + i + '&lt;/li&gt;';//字符串拼接的方法，这里循环2次所以有2个li &#125; list.innerHTML = list.innerHTML + str;向元素中添加str（2次li） //list.innerHTML += str; 总结 : 动态创建和innerHTML 动态创建的方式并不会影响原有元素的任何属性,但是操作不便还有可能引起多次回流 innerHTML的方式操作起来比较简便，但是它会破坏原有元素的属性。不存在任何元素用比较合适 =&gt; 模板引擎 动态添加：appendChild/insertBefore（新，旧），麻烦，有可能引起多次回流，innerHTML的方式：拼接字符串。简便但是会影响页面已经存在的元素。如果页面中不存在元素；使用拼接字符串的方式比较好。 排序的时候加.innerHTML的时候，是因为sort（A,B）里面不是数字不能相减，所以需要元素内部的数字，内容可以相减的话需要用innerHTML使用innerHTML会影响原来存在的元素，比如事件丢失， JSON数据格式定义：就是一种数据格式，跨平台里面的兼容性最好 JSON格式 : 属性名字用双引号包含，属性值如果是字符串也用双引号包含 在ie7-不兼容 123456789var obj = &#123; // js对象 name : 'cb', age : 8 &#125;; var jsonObj = &#123; // json格式的对象 \"name\" : \"cb\", \"age\" : 8 &#125;; console.log(window.JSON); // JSON对象 json方法 JSON.parse : 把json格式的字符串转化成json格式的对象 eval也可以转化成js代码执行 JSON.stringify : 把json格式的对象转化成一个json格式的字符串 ps : 在IE7以下不兼容 12345var res = JSON.stringify(jsonObj);//stringify：json对象转化成字符串 console.log(res); var res1 = JSON.parse(res);//parse：字符串转化成json对象 console.log(res1); 但是json方法不兼容，用eval的方式来处理兼容问题的，只是在ie7以下不兼容，在谷歌浏览器及其他浏览器下兼容12345678910function jsonParse(jsonStr)&#123;//使用一个方法来让json方法兼容if(window.JSON)&#123; // 对象 undefined 判断真假，真的话执行，如果json在window下定义的话，说明兼容当前浏览器，所以执行下面的字符串转对象方法 return JSON.parse(jsonStr); &#125;else&#123; // ie7- 如果不兼容说明是在ie7-，所以执行eval的方法，执行字符串拼接，最后再输出字符串 return eval('('+jsonStr+')'); &#125;//两个都添加return，最后都要求输出 return window.JSON ? JSON.parse(jsonStr) : eval('('+jsonStr+')'); return \"JSON\" in window ? JSON.parse(jsonStr) : eval('('+jsonStr+')'); &#125;&#125; JSON和普通对象的区别，属性名需要用双引号包含，属性值是字符串的话，那也用双引号。如果是最后一个1和0的数字求值，不能用引号JSON是定义在全局的一个变量，window.JSONJSON.stringify，对象转字符串 加双引号JSON.parse 字符串转对象 去双引号ie7以下不支持eval也可以去双引号 由于JSON方法在ie7-不兼容，下面多一个方法检出处理兼容问题1234function jsonParse(jsonstr)&#123; // 简单处理兼容问题的方法 return 'JSON' in window ? JSON.parse(jsonstr) : eval('('+jsonstr+')'); &#125; in运算符：判断一个属性是否属于一个对象 ==》返回布尔值所有的属性名都是字符串1234567//In是判断一个运算符是不是一个对象//in运算符主要是判断一个属性是否是一个对象//共有属性和私有属性都可以判断。in：“setinterval” in window //判断一个属性是否属于一个对象， 返回一个布尔值//ps：共有属性能调用也是真//ps：判断属性名字要用字符串， ‘JSON’ in window 交互逻辑（简单的交互模型） 用户在网页（前端）搜索条件，请求带着数据到后台，后台准备数据，到数据库中查询，查询到数据后，吧数据拼凑成我们所需要的dom结构，然后添加到页面中，进行展示，构成页面的结构 后台分为：net php java python 处理请求（商店店员）带着需求，到数据库查询 找到后，返回到后台 。到后台准备数据，（把从数据库中查询来的结果组合成前端所需要的数据格式） 这样的格式是json（这个格式适应大部分平台） 一般情况下是一个对象 数据库一本分为：Oracle（大型企业） mysql sqlsevele 存的都是数据 表结构（一组数据）（手机有手机的表结构，电脑有电脑表结构） 字段（属性名）","tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"},{"name":"js入门","slug":"js入门","permalink":"http://yoursite.com/tags/js入门/"}]},{"title":"2.1 原型、call、apply、bind、继承(属性+方法)","date":"2016-10-02T16:00:00.000Z","path":"2016/10/03/2.1 原型、call/","text":"知识点： localCompare：字符串按照首字母排序 在script下添加&#39;use strict&#39;属于严格模式，放在script 下面第一项 只有函数包含，prototype （共有属性） proto（永远指向所属类的原型） 每一个内置类都是一个实例 object var ary = []ary.push( );数组+方法是一个函数数据类型 只要敢给他加小括号，他就是函数，math，max（）前面都是函数 ary.join ( ) 在没有传值的情况下，可以让数组变成字符串 eval能够把字符串变成js执行 object是属于数字类型，对象数字类型；Object 是属于类 类数组没有数组中的方法，但是类数组有索引有length，可以将类数组转成数组，类数组一般在于获取元素中li中得到 HTML Collection 元素集合 相当于类数组 localecompare （） 本地对比 按照首字母排序 最常用的是call方法 这三个方法定义在函数类的原型上，相对于每个函数类实例来说都是公有方法。每个函数都可以调用这三个方法 调用call方法，必须保证是一个函数 call是一个函数所以后面可以加（） Function.prototype里的call apply bind，只有函数才可以用，这三个方法都是用来改this的。 原型 每个函数都有prototype这个属性 每个原型中都带有，constructor和proto prototye里添加的内容都是公有属性 prototype如果没有点，会直接替换掉 然后constructor会丢失 array.prototype={} 任何一个引用数据类型都带proto proto永远指向自己所属类的原型 每一个实例都是引用数据类型，都带有proto 所有的函数都是 Function这个类的一个实例，都指向Function.prototype Function.prototype相对于每个Function类的实例来说也是公有方法 call apply bind 相同点：都可以改this，第一项都是this的代替值不同点：call是改实例中的this；apply是传一个数组，并将其每一项传值给function实参进去；bind只改this，不执行函数（所以只传this就行了） call定义的位置：function.prototype.call 定义在函数这个类的原型上 ，相对于function这个类的实例来说，都是公有方法，直接实例点调用就可以了123fn.__proto__ === Function.prototype; Function.prototype.call = function( )&#123; &#125; fn.call() call方法执行步骤首先call必须保证是一个函数 首先先获取到定义在原型上的Function原型Function.prototype上的call方法 然后把调用call方法这个函数(实例)中的this修改成call的第一个参数。 调用call方法的这个函数执行 ps：call从第二个参数开始，传给调用call的函数实例形参ps：调用过call方法之后的函数也是执行过的，ary.call()这个也算是函数执行。ps：只有函数可以调用call这个方法，所以保证call前面必须是一个函数ps：call第一个参数用来改this，谁点我，this就是谁 123function sum(num1,num2)&#123; console.log(this); sum.call（this，1，2）//默认this是window 不需要改this的话，随便赛一个null 和 undefined （严格模式和非严格模式的区别）&#39;use strict&#39; &#39;use strict&#39;从现在开始js代码按照严格模式执行,写在开头。 使用call的时候，，如果把this修改成null或者undefined，严格模式下写什么就是什么；在非严格模式下是window。 自运行函数this在严格模式下，是undefined非严格模式下是window 函数执行中的this，如果前面没有&quot;.&quot;的情况下fn()，非严格是window，严格模式下是undefined call第一个项都是改this，从第二个参数开始，都是传给前面的函数的形参的（传给调用call的函数实例）非严格模式下，自运行函数和函数执行没点中的this都是 window一般定义在类的原型上的方法中的this都是 实例 apply定义：apply和call方法基本相同，apply的第二个参数是一个数组，会把数组中的每一项作为调用apply方法的函数实例的参数（简单说来就是数组的每一项为实参，按数组的每一项传给形参） ps：和call一样，在修改完this之后之后，直接把函数执行了apply和call的方法基本相同， 第一个参数都是改this的 第二个参数是一个数组，把数组中的每一项当做参数传给调用apply的那个函数的 和call一样，只要apply执行过了相当于调用apply的函数也执行了。 12345678910111213141516171819202122// apply使用 function sum(num1,num2)&#123; console.log(num1 + num2); &#125; sum.apply(null,[100,200]);//数组的每一项分别按实参传值 var ary = [1,2,3,4,5]; // 求数组里最大值 // 1 ary.sort(function (a,b)&#123; return b -a; &#125;);//倒叙的方式排列，然后取第一项即可 a , b分别就是数组中要比较的相邻两项 // 2 利用就是apply这个方法特殊的传参的方式 Math.max.apply(null,ary); // =&gt; Math.max(1,2,3,4,5) 把ary这个数组按每一项传到.apply前面的这个函数中，因为apply还有this所以需要给赋空； // 3 假设 这个假设思想 var max = ary[0];//首先拿第一项，我们假设他是最大的值 for(var i = 1; i &lt; ary.length; i++)&#123; if(ary[i] &gt; max)&#123;//后面的每一项如果比第一项大的话，就把最大的那一项赋值给第一项，然后再进行比较 max = ary[i];//最后max就是最大的一项 &#125; &#125; // 4 eval eval( \"Math.max(\" + 1,2,3,4,5 + \")\" ) eval的功能是把字符串变成js代码执行；ary.join()是把数组变成字符串 eval('Math.max('+ary.join()+')');//字符串拼接，然后再执行 bind定义：call和apply都已经把函数执行结束，bind返回了一个修改了this的新函数，它跟原有函数不是同一个，bind不会执行函数，只改this ps：一般使用bind的时候，一般只修改this，返回值执行的时候才传参，方法不兼容bind和call和apply不一样，最大的区别是没有把调用bind的函数直接执行，而是返回了一个修改好this的新函数。以后返回的新函数还可以继续执行， ie不兼容 123456789function func(num1,num2)&#123; console.log(this); console.log(num1 + num2); &#125; var res = func.bind(document/*,1000,2000*/);//这里传值没有意义，因为每次函数执行都是这两个值，所以只改this就行 //console.log(res === func); bing的作用会返回一个新的函数 res(1000,2000); // 3000 所以只在执行的时候传值就行了。 res(2000,3000); // 5000 如果只有一个call的时候，call前函数执行， 吗多个call其实就是括号里的 第一个参数执行， 1234function fn1()&#123; console.log(1) &#125;function fn2()&#123; console.log(2) &#125;// 没有this就不需要改，直接传值就可以fn1.call(fn2); // fn1执行 ，如果只有一个call的时候，call前的函数执行fn1.call.call(fn2); // 多个call其实就是第一个参数执行 Object.prototype.toString.callObject.prototype.toString.call( [ ] )定义：相当于call把tostring方法中的this修改成了这个数组，而原型上方法中的this一般是实例，已经把this更改成了这个数组。那么tostring就被数组偷偷的调用了一次 Object原型上的toString方法打印结果是&quot;[object Object]&quot;这样的字符串。后半部分就是标记当前实例所属的类，前面不变都是object数据类型；只有花括号才会返回&quot;[object Object]&quot;。 for in 循环只能便利自己设置的属性值和属性名，（私有属性，公有属性）。这个属性就叫做可枚举属性，（就是能见光的属性）能一一列举的属性。 1234567var obj = &#123; \"name\" : 'cb', age : 8 &#125; for(var key in obj)&#123; console.log(typeof key); // 'string'每一个属性名都是字符串类型的 &#125; hasOwnPromerty 自己的私有属性，可枚举属性：propertyIsEnumerable 12345678910function Human()&#123; this.name = 'abc'; &#125; //定义一个类Human.prototype.cry = function ()&#123;&#125; // constructor 在这个类的原型上添加一组属性名和属性值 var h1 = new Human();//创建一个实例 for(var key in h1)&#123; //便利h1当中的每一项属性名 if(h1.hasOwnProperty(key))&#123; // 如果属性名在h1中的私有属性的话，那么就输出这个属性名 console.log(key); &#125; &#125; 用在sort里面升序的话就是-1降序的话就是1如果是三个字母和2个字母排序的话，只比2个字母如果是两个相等就是0 12345678910111213141516171819202122232425262728293031323334//对象里面属性名属性值排列var ary = [obj1,obj2,obj3,obj4]; ary.sort(function (a,b)&#123; // a , b分别就是数组中要比较的相邻两项 // a : &#123;name : 'tian',age : 31&#125; b : &#123;name : 'wang', age : 18&#125; //return a - b; // return的这个a-b的差就是是否交换位置的依据 return a.name.localeCompare(b.name); // 字符串排序 按照字母的先后排列 如果是汉字会转换成拼音 return a.age - b.age; &#125;); console.log(ary);// 数字排序 var a = [1,3,2,5,4]; a.sort(function (x,y)&#123; return -1;//如果是-1说明排序是从小到大，如果是1，那说明是从大到小 &#125;); console.log(a); // 1,2,3,4,5// var list = document.getElementById('list'); var lis = list.getElementsByTagName('li'); // [li,li,li,li] // 如何把一个类数组转化成数组 ?? var ary = []; for(var i = 0, len = lis.length; i &lt; len; i++)&#123; ary.push(lis[i]); &#125; // getAttribute('price') 获取一个属性，只需要给出属性名即可 // setAttribute('price','val') 设置一个属性，需要给出属性名和属性值 // removeAttribute('price') 移除这个属性，只需给出属性名即可 ary.sort(function (li1,li2)&#123; return li1.getAttribute('price') - li2.getAttribute('price'); &#125;);//排序，根据li的属性名得出的属性值，进行升序排列 console.log(ary); // ....明天将的内容 如何把已经排好序的这个数组和页面中的li元素结合起来 dom映射 常用几种继承：1）属性都是私有的，2）方法都是公有的 原型继承：（为了继承公有的属性）利用修改prototype成对方的实例实现获取数据 1234567891011// 原型继承 =&gt; 公有 function A()&#123; // 父类 this.x = 100; this.y = 200; &#125;A.prototype.getX = function ()&#123;&#125;B.prototype = new A()B.prototype.constructor = Bvar b = new B();b.getX(); call继承（为了继承私有属性） 12345678910111213function C()&#123; this.x = 100; // d.x = 100; this.y = 200; // d.y = 200; &#125; C.prototype.getX = function ()&#123;&#125; function D()&#123; // this =&gt; d C.call(this); //要把C函数中的this修改成d实例 &#125; var d = new D(); console.dir(d); // // 混合继承 原型继承+call继承 ... 混合继承 原型继承+call继承继承就是，想把别家的东西拿过来。","tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"},{"name":"js入门","slug":"js入门","permalink":"http://yoursite.com/tags/js入门/"}]},{"title":"1.3 this用法、单例模式、构造函数模式","date":"2016-10-01T16:00:00.000Z","path":"2016/10/02/1.3 this/","text":"知识点 弹窗的3种方式： alert（） confirm（） prompt（） 预解释在代码执行之前已经完成 预解释也是从上到下执行 在预解释阶段：如果函数名和变量名名字相同，表示都声明过了，在预解释阶段以最后一个函数为准，当代码执行到变量赋值的那一行，以这个变量为准 形参相当于函数体内的私有变量，而且还有值 若函数里没有需要的值会向上找上一级作用域：跳出当前函数，谁包着你，谁就是上级作用域，顶级作用域是window var f =fn() var f1=f f =null 即使f被释放，f1也不会被释放 typeof fn ==&quot;function&quot;&amp;&amp; fn( )这行代码说明&amp;&amp;前面的满足后，后面的执行 形参没有赋值，那形参的变量是undefined ；undefined+1=nan 123var obj =&#123;num:1 age:2 &#125;obj.age=2 //这=号和对象&#123;&#125;里面的：其实都是给age赋值的意思。 this的用法（函数中） 绑定事件函数中的this：当事件触发的时刻，绑定给哪个dom元素，this就是谁 obj.fn（） fn函数中的this是obj了：函数执行时，函数中的this就是执行这个函数的对象名==》&#39;.&#39;前面是谁，这个函数中的this就是谁，没有’.‘是window;函数执行时的this，就看函数执行时刻，&#39;.&#39;前面是谁，如果有；this就是它，如果没有；this就是window， 只要有函数包含执行带有this的这个函数，那么this一定会发生改变 只有函数执行的那一刻，才确定函数中的this。比如fn（）；obj.fn（） fn( ) 和 obj.fn( ) 执行的是同一个函数，由于执行方式不同导致this不同。 函数定义的时候this不能确定，只有执行的时候才能确定，因为我没有看它执行的方式 打印一个属性，要么有，要么undefined，比如win.xxx，打印为undefined123function()&#123; &#125;var ary =[print]ary[0]();//this是数组，是ary这个数组 自执行函数中的this就是 window（非严格模式下） 定时器函数中的this一般都是window就算里面是obj.obj，这个函数中的this也是window 构造函数中的this是当前实例 call&amp;apply&amp;bind都可以强制修改this（js中提供三个方法可以强制改this） 回调函数中的this一般也是window 1234567891011div1.onclick = function () &#123; this; // div1 &#125;function fun() &#123; console.log(this); &#125; var oo = &#123; fun: fun,//对象中用，把每个属性分开 name: 'montyyuan' obj:function()&#123; fun&#125;//这里的fun里的this因为有函数包裹，所以this属于window &#125; oo.fun()//函数执行，fun中的this是oo的(function () &#123; console.log(this); //自执行函数中的this是window &#125;)();window.setInterval(oo.fun,1000); // 定时器中的this是window 全局中的this是window 只要有函数包含执行带有this的这个函数，那么this一定会发生改变 函数刚定义完（没有执行），this是谁不知道，只有执行的时候，谁&#39;.&#39;我，this就是谁，如果没有‘.’，那就是window 只有函数执行的那一刻才能确定函数中的this 比如 fn（） obj.fn( ) fn( )和obj.fn( ) 执行的是同一个函数，由于执行的方式不同，导致this不同没有被函数包着的this都是window的属性，实参里的this都属于window，只有函数里的this才有他的宿主 两种方法（判断this）： 第一种是this所在的函数执行 fn（）fn前面的.前面是谁，this就是谁 第二种是： 主要就是把this所在的函数，看做一个整体，谁执行这个整体，点前面是谁this就是谁。 1234567891011var obj = &#123; obj: function fm() &#123; console.log(this) return function fn() &#123; console.log(this) &#125; &#125; &#125;//查看当前this所在的位置 fn()//w， obj.fm()()//obj,w obj.fm()//obj 12345678910111213141516//简单一个案例，试着做一下var num=1; var obj=&#123;num:2&#125;; obj.fn=(function (num) &#123; this.num+=2; num--; return function (n) &#123; this.num+=2; num--; console.log(n+ ++num); &#125; &#125;)(this.num); var fn=obj.fn; fn(1);//fn前面没有.默认就是window obj.fn(2); //和上面一样都是执行同一个函数，只不过前面有.，关键就是看执行的这个带有this的函数，前面的.是谁，就是谁 console.log(num,obj.num); 单例模式 本质：其实就是一个对象（花括号）用对象作为一个模块的划分 解决命名冲突（函数名与函数名冲突） 代码模块化（方便代码管理） 最常用的（大部分公司都是 单例模式） 又叫做命名空间==&gt;nameSpace 每个单例模式中，属性和属性之间的调用使用this就可以。比如在guonei.fn1中调用fn2直接使用this.fn2，就直接在fn1函数中的this.fn2即可，不过这样容易形成循环 12345678910var guonei =&#123; num: 10 fn1 ：function ()&#123; this.fn2 &#125; fn2 : function ()&#123; this.fn1 this.num &#125; &#125; guonei.fn1() 构造函数（类） 内置类：基本数据类型：Number String Boolean 引用数据类型：Array Object Date RegExp Function HTMLDivElement/如果是p标签就是 p标签的全称 为什么定义一个类，因为原来的不够用。类：其实就是一个函数（定义一个函数和定义一个函数都用关键字function） 实例：具体到这个类的某一个；创建一个实例用关键字 new Tab（） instanceof：判断一个实例是否属于一个类 函数角色：普通函数、构造函数（类）、function这个函数内置类的一个实例 当做构造函数（new的方式执行）那么会有默认返回实例的动作（不写return也会返回实例） 每个实例都是一个对象数据类型var tab1 = new Tab ( 100,200) 在构造函数中如果return一个引用数据类型，会破坏实例的默认返回动作，非return 就this吧 构造函数中的this就是当前实例（正在使用new运算这个实例） typeof ：’number’ ‘boolean’ ‘string’ ‘object’ ‘function’ ‘undefined’instanceof ：判断一个实例是否属于一个类constructorObject.prototype.toString.call（） 12function Tab ( )&#123; &#125;//定义了一个选项卡的类var tab1 = new Tab ( )//创建了一个实例 原型模式 比如有的方法，不应该作为私有属性，就像FE前端工程师就应该会写代码 任何一个函数天生自带一个属性叫做prototype，并且属性值任然是一个对象，并且这个对象天生自带一个属性叫，constructor；它的属性值是函数本身。 1FE.prototype.constructor===FE //true 任何一个实例也天生自带一个属性：__proto__这个属性值就是 这个实例所属类（构造函数）的原型 1FE.prototype===fe1.__proto__ // true ps：由于每个实例都会自带__proto__属性，那么每个实例都可以通过这个属性访问自己所属类的原型，这个原型其实就是相对于每个实例来说，就是公共区域；公共区域内的属性也随之变成了公有属性；实例__proto__属性其中这个获取方式__proto__可以省略12FE.prototype.coding= function ()&#123; &#125; 相当于在原型 上添加了一个coding属性fe1.__proto__.coding === FE.prototype.coding ps1：直接添加共有方法，直接添加在类 （构造函数）的（原型）prototype属性上即可 ps2：任何一个引用数据类型，都天生自带__proto__属性，并且这个属性（引用数据类型）永远指向所属类的原型 ps3：定义在类的原型上的方法，比如FE.prototype.coding，一般由实例来调用，那么构造函数中的this一般就是这个实例 后面加个小括号的都是函数数据类型 由于执行方式不同，区分普通函数和构造函数 定义：如果没有这个类，需要自己创建一个类，就叫做构造函数 举例：function Tab ( ){ } //没有tab这个类，就需要自己创建这样一个类，new是我想造这个类的一个实例然后实例执行：var tab = new Tab大括号里的是实例的执行内容既然我创造了它，怎么区分呢？如何区别？就看怎么执行他，是一个函数还是一个类，函数的话执行是Tab（）；类的话创建实例是var tab = new Tab 实例：具体到类中的某一个，每一个实例都是一个对象数据类型Objcet ps：每一个数组都是Array这个类的一个实例 ps：每一个函数都是Function这个类的一个实例，无论是实名还是匿名、自执行函数内置类 ps：咱们班每一个人都是Chinese中国人这个类的一个实例 ps：instanceof 专门判断一个实例是否属于一个类的，返回布尔值 如何定义一个类 function Tab ( ){ }和定义函数相同 ps：既是普通函数、构造函数（类）、又是Function这个类的一个实例 ps：构造一个类尽量使用首字母大写 ps：构造函数中的this就是当前实例 =&gt; 如果想在实例添加私有属性；就在构造函数中添加 this.属性名， ps：函数会默认返回一个实例，但是不能在构造函数中再写return一个引用数据类型变成一个函数（return基本数据类型不影响构造函数结构，但是实例不会读取） 12345678910111213function Human(weight,height)&#123; //var abc = 1000; // 这个私有变量不会对实例产生过影响 this.weight = weight/*&apos;4kg&apos;*/; this.height = height/*&apos;0.3m&apos;*/; //return //构造函数会默认return一个实例 //return [];引用数据类型会影响构造函数的结构 &#125;要想往实例上添加内容，必须用this var lilei = new Human(&apos;4kg&apos;,&apos;0.3m&apos;);//Human &#123;weight: &quot;4kg&quot;, height: &quot;0.3m&quot;&#125; var hanmeimei = new Human(&apos;5kg&apos;,&apos;0.4m&apos;);//Human &#123;weight: &quot;5kg&quot;, height: &quot;0.4m&quot;&#125; console.log(lilei); console.log(hanmeimei); 每个类都是一个函数的一个实例无论怎么造一个新的类都是对象（引用数据类型）的一个实例 所有的引用数据类型都是Object这个类的实例标签元素也是Object对象类的一个实例标签元素分为：HTMLDivElement、 Array instanceof Function //true[ ].push instanceof Function //true 数组执行方法也是函数类的一个实例","tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"},{"name":"js入门","slug":"js入门","permalink":"http://yoursite.com/tags/js入门/"}]},{"title":"1.2 引用数据类型赋值、闭包、内存释放","date":"2016-09-30T16:00:00.000Z","path":"2016/10/01/1.2 闭包/","text":"只要代码执行的会形成一个全局作用域，只要浏览器一打开就形成 函数执行会形成一个私有作用域 堆内存是用来存值的，栈内存是用来运行代码的 引用数据类型赋值的过程 浏览器先给开辟一块堆内存 如果是对象那么就把键值对当字符串存入到这个内存中，如果是函数就把函数体内的代码当做字符串存入内存中 把这个内存地址返回 123456var num =10var obj =&#123; num:10; fn:function()&#123;&#125;; num1:obj.num //报错返回未定义：在赋值的过程中不能使用当前变量,因为变量（引用数据类型）赋值的过程还没有结束 &#125; 因为在对象开辟内存，将键值对变字符串存值的时候，里面的属性值不能用当前变量，因为当前变量还没有操作结束，整个对象赋值的过程有三步，第三步结束后才能用这个变量名。所以在赋值的时候属于第二步，不能用未结束的变量名 闭包定义：当函数执行的时候，就会形成一个私有作用域（栈），这个私有作用域 保护私有变量不受外界干扰，这种机制就叫做闭包 1234function fn ()&#123; var num =10 &#125; fn()//fn执行的时候形成一个私有作用域，并且把里面这个变量(var num =10)保护起来，形成了一个闭包，---》闭包形成前提条件是得有函数执行 12345function sum ()&#123; haha =50//如果是一个赋值的过程`haha=50`，最不济也能赋值成全局变量，如果是取值过程`console.log`，到全局变量还有没有获取，那么就只能报错了 window.x = 100; // 多了叫做x的全局变量，并且值为100，所有的全局变量都可以认为是window对象的一个属性 &#125; var f = sum()//赋值过程：先准备值，准备等号右边的，在给左边 内存释放（堆\\栈）函数执行的时候会形成一个私有作用域，并且定义在函数中的一部分（引用数据类型）被函数外的变量或者对象的属性所占用，那么就符合作用域不释放的条件，其实就是这个函数执行的时候产生的那个作用域不被释放，所以在这个作用域定义的私有变量就会被保存下来。 只要这个（堆、栈）没有被占用，就可以释放 内存满：如果有函数执行一次就会有一次内存，如果有循环就会有很多次执行完后的内存，内存终有一天填满，或者对象类型函数类型的堆内存 引用数据类型其实就是堆内存地址 让堆内存释放：让这个对象=null js不能释放内存，回收是浏览器的事情，每个浏览器回收机制不一样 函数执行完就自动释放了 堆释放：引用数据类型存值12345var obj = &#123; // obj就在占用这个对象的堆内存地址，所以这个堆不能释放 name : &apos;zhufeng&apos;, age : 8 &#125;; obj = null; // obj这个变量再也不占用对象的堆内存地址。 栈（作用域）释放函数执行形成 重要：（不释放） 函数执行的时候（fn），会形成一个私有作用域， 假如函数fn中的 一部分（必须是引用数据类型return后面的 函数（你不return出来，你有闭包保护机制，我进不去，我怎么拿到你的值，我就没办法利用我函数外的身份占用你，除非我进去。）） 被函数（fn）外面的变量 f 或者对象的属性所占用，那么（fn）执行形成的作用域就符合不被释放的条件； 从而这个作用域内的私有变量（total=12甚至形参（c）都能保存下来并可以进行修改） 栈内存不释放原则 全局变量f占用return出来的匿名函数，符合fn函数执行形成的作用域不被释放的条件 如果不return出来，那么可以到函数内部去占用这个返回值函数里面的一个引用数据类型被函数外面的一个属性（变量和方法）给占用了。就符合函数不被释放的原理，作用域也不释放 在绑定事件过程中，也有可能和作用域不释放参合在一起 不立刻释放作用域 123456function fun()&#123; var i = 0; return function ()&#123; //外面的fun先留着不释放，等里面的函数执行完了以后，一起释放 console.log(++i); &#125;&#125; 123456789101112var div1function fn(c)&#123; var total =12;//作用域不释放，变量报保存下来了，也可以修改 return function foo()&#123; total +=120 //函数中的12既然保留下来了，那么就可以修改&#125; window.f =foo//属性值占用（都可以使私有作用域不释放） div1.onclick =foo//绑定事件的方法，利用属性占用（函数中的一部分foo这个引用数据类型被函数外界的变量或者属性名所占用了，符合作用域不被释放的条件）&#125; var f =fn()//全局变量f占用fn函数执行的结果 document.body.xxx = fn()// f() 12345678910111213function fm ()&#123; var total =10; return foo function foo()&#123; total+=total console.log(total)&#125;&#125;var f =fm()f()//20f()//40var ary =fary()80 dom对象为object属性类型任何一个全局变量都可以认为是window的一个属性在作用域查找的过程中，如果是赋值过程，先查找私有作用域，如果不存在查找上一级作用域，如果到全局还没有，那么这个值就直接赋值给window的一个属性。 作用域不释放 用全局变量或者对象的属性去占用一个函数执行返回的引用数据类型的值 return 用一个dom对象的事件属性去占用一个定义在函数执行内部的引用数据类型值123（function ()&#123; document.body.onclick = fucntion ()&#123;&#125; // 虽然没有return这个匿名函数 ，但是任然符合占用关系 &#125;） 事例：1234567891011121314151617181920var num =1 //全局变量只有关闭页面才会销毁，所以每次都是次序的累加function fn ()&#123; num++ return function()&#123; num++; console.log(num)&#125; &#125;var f1 = fn(num) //全局变量永远不会销毁f1() // 3 执行到这的时候，全局已经变成2，执行return变成3f1=fn(num) //执行这一步的时候，又执行了一次fn ，全局的数字变成了 4f1() //5 执行到这的时候，全局为4 ，执行结果是5fn()() //7 fn()() //9 每次修改都是在修改全局的变量，全局变量不释放，只有关闭浏览器才会释放全局变量的值。//如果形参为num的话 1 2 var f1 = fn(num) //这个也需要执行，fn（num）为私有作用域num-1f1() // 就跟全局的变量没有关系，在私有作用域里面计算，num++ =2f1 =fn(num) // 这个重新再传了一个1值，然后再执行num++ = 2f1（） // 只执行return后面的函数，所以在2的基础上+1fn（）（） // 这里注意由于没有传值，所以形参只定义不声明，所以num为undefined 而任何数+undefined都为NaNfn（）（） // 这一步和上一步操作一样 暂时不释放 函数执行结束返回的函数立刻执行 fn（）（） i++和++i 没有和其他值运算 ，效果都是自身累加1 i++是先运算后再自身累加 ++i 先自身累加后运算 ++i，是一种强制转换数字的默认行为 实例：点击计数 事件函数从里面占用导致函数外不释放，变量不释放 123456;(function ()&#123; var count = 0; // 1 document.body.onclick = function ()&#123; count++; this.innerHTML = count; &#125; &#125;)(); 事件函数占用函数里return出来的值，使函数不释放、变量不释放 12345document.body.onclick = (function ()&#123; var count = 0; return function ()&#123; document.body.innerHTML = ++count; &#125; &#125;)(); 自定义属性的方式 =&gt; 一般配合事件中的this =&gt; 给谁绑定事件自定义属性就添加给谁 1234document.body.count = 0;document.body.onclick = function ()&#123; this.count++; this.innerHTML = this.count; 使用innerHTML 123456var div1 = document.getElementById(&apos;div1&apos;); div1.onclick = function ()&#123; //++this.innerHTML; 第一种方法 //div1.innerHTML = div1.innerHTML/1 + 1; 第二种方法/-*1都可以 div1.innerHTML = ++div1.innerHTML; // ++i也有强制转化为数字的默认行为 &#125; 全局变量永远不会销毁","tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"},{"name":"js入门","slug":"js入门","permalink":"http://yoursite.com/tags/js入门/"}]}]